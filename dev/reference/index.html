<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Technical reference · Peacock.jl Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Peacock.jl Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit">Peacock.jl Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/getting_started/">Getting started</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../how-tos/zoo/">How to load a crystal from the Zoo</a></li><li><a class="tocitem" href="../how-tos/wilson_loops/">How to study band topology with Wilson loops</a></li></ul></li><li class="is-active"><a class="tocitem" href>Technical reference</a><ul class="internal"><li><a class="tocitem" href="#Public-interface"><span>Public interface</span></a></li><li><a class="tocitem" href="#Private-interface"><span>Private interface</span></a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Technical reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Technical reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sp94/Peacock.jl/blob/master/docs/src/reference/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="reference"><a class="docs-heading-anchor" href="#reference">Technical reference</a><a id="reference-1"></a><a class="docs-heading-anchor-permalink" href="#reference" title="Permalink"></a></h1><h2 id="Public-interface"><a class="docs-heading-anchor" href="#Public-interface">Public interface</a><a id="Public-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Public-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Peacock.BrillouinZoneCoordinate" href="#Peacock.BrillouinZoneCoordinate"><code>Peacock.BrillouinZoneCoordinate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BrillouinZoneCoordinate(p::Float64, q::Float64, label::String=&quot;&quot;)</code></pre><p>A labelled coordinate in the Brillouin zone.</p><p>The arguments <code>p</code> and <code>q</code> are the coefficients of reciprocal lattice vectors <code>b1</code> and <code>b2</code>. The k-space coordinate, <code>k = p * b1 + q * b2</code>, is generated by <code>get_k(coord::BrillouinZoneCoordinate, basis::PlaneWaveBasis)</code>. For example, <code>BrillouinZoneCoordinate(0.5,0)</code> is on the edge of the first Brillouin zone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plane_wave_basis.jl#L69-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.Geometry" href="#Peacock.Geometry"><code>Peacock.Geometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Geometry(a1::Array{Real,1}, b1::Array{Real,1}, ep::Array{ComplexF64,2}, mu::Array{ComplexF64,2})</code></pre><p>2D geometry defined in real space, with lattice vectors <code>a1</code> and <code>a2</code>, and relative permeability and permittivity <code>ep</code> and <code>mu</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/geometry.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.Geometry-Tuple{Function,Function,Array{#s18,1} where #s18&lt;:Real,Array{#s19,1} where #s19&lt;:Real,Real,Real}" href="#Peacock.Geometry-Tuple{Function,Function,Array{#s18,1} where #s18&lt;:Real,Array{#s19,1} where #s19&lt;:Real,Real,Real}"><code>Peacock.Geometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Geometry(epf::Function, muf::Function, a1::Array{&lt;:Real,1}, a2::Array{&lt;:Real,1}, d1::Real, d2::Real)</code></pre><p>Generate geometry with permittivity <code>epf(x,y)</code> and permeability <code>muf(x,y)</code>.</p><p>The real space lattice vectors, <code>a1</code> and <code>a2</code>, define the unit cell. The grid resolution along each lattice vector is <code>d1</code> and <code>d2</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/geometry.jl#L15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.Geometry-Tuple{Function,Function,Real,Real,Real,Real}" href="#Peacock.Geometry-Tuple{Function,Function,Real,Real,Real,Real}"><code>Peacock.Geometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Geometry(epf::Function, muf::Function, a1::Array{&lt;:Real,1}, a2::Array{&lt;:Real,1}, d1::Real, d2::Real)</code></pre><p>Generate geometry with permittivity <code>epf(x,y)</code> and permeability <code>muf(x,y)</code>.</p><p>The real space lattice vectors are assumed to have unit length and are at angles <code>a1_deg</code> and <code>a2_deg</code> counter-clockwise from the x-axis. The grid resolution along each lattice vector is <code>d1</code> and <code>d2</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/geometry.jl#L39-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.HilbertSpace" href="#Peacock.HilbertSpace"><code>Peacock.HilbertSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HilbertSpace(k0, data, weighting, basis)</code></pre><p>Hilbert space spanned by the eigenvectors in each column of <code>data</code>.</p><p>The eigenvectors will be orthonormalised using Gram-Schmidt orthonormalisation, see <a href="#Peacock.orthonormalise-Tuple{Any}"><code>orthonormalise</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/modes.jl#L15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.HilbertSpace-Tuple{Array{Mode,1}}" href="#Peacock.HilbertSpace-Tuple{Array{Mode,1}}"><code>Peacock.HilbertSpace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HilbertSpace(modes::Array{Mode,1})</code></pre><p>Returns the Hilbert space spanned by the <code>modes</code>.</p><p>The <code>data</code> of the Hilbert space is guaranteed to be orthonormal under the weighting of the <code>modes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/modes.jl#L37-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.Mode" href="#Peacock.Mode"><code>Peacock.Mode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Mode(k0, frequency, data, weighting, basis, label)</code></pre><p>Eigenmode of a photonic crystal expressed on a plane-wave <code>basis</code> with a weighted inner product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/modes.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.Solver" href="#Peacock.Solver"><code>Peacock.Solver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Solver(basis::PlaneWaveBasis, epc::Matrix{ComplexF64}, muc::Matrix{ComplexF64})</code></pre><p>A plane-wave expansion method solver, where <code>epc</code> and <code>muc</code> are the convolution matrices of the permittivity and permeability, respectively, for the given <code>basis</code> of plane waves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/solver.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.Solver-Tuple{Geometry,Int64,Int64}" href="#Peacock.Solver-Tuple{Geometry,Int64,Int64}"><code>Peacock.Solver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Solver(geometry::Geometry, cutoff_b1::Int, cutoff_b2::Int)</code></pre><p>Approximate the geometry using a basis of plane waves truncated in a rhombus.</p><p>The rhombus has lengths <code>cutoff_b1</code> and <code>cutoff_b2</code> in the <code>b1</code> and <code>b2</code> directions, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/solver.jl#L48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.Solver-Tuple{Geometry,Int64}" href="#Peacock.Solver-Tuple{Geometry,Int64}"><code>Peacock.Solver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Solver(geometry::Geometry, cutoff::Int)</code></pre><p>Approximate the geometry using a basis of plane waves truncated in a circle.</p><p>The circle has a diameter of <code>cutoff</code> Brillouin zones. Increasing the <code>cutoff</code> will increase the number of plane waves leading to a more accurate solution. It is assumed that <code>norm(b1) == norm(b2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/solver.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.Solver-Tuple{Geometry,Peacock.PlaneWaveBasis}" href="#Peacock.Solver-Tuple{Geometry,Peacock.PlaneWaveBasis}"><code>Peacock.Solver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Solver(geometry::Geometry, basis::PlaneWaveBasis)</code></pre><p>Approximate the geometry using the given <code>basis</code> of plane waves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/solver.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.get_field-Tuple{AbstractArray{#s38,1} where #s38&lt;:Complex,Peacock.PlaneWaveBasis}" href="#Peacock.get_field-Tuple{AbstractArray{#s38,1} where #s38&lt;:Complex,Peacock.PlaneWaveBasis}"><code>Peacock.get_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_field(data::AbstractVector{&lt;:Complex}, basis::PlaneWaveBasis;
                    k0=[0,0], t1s=-0.5:0.01:0.5, t2s=-0.5:0.01:0.5)</code></pre><p>Convert the <code>data</code> from a <code>PlaneWaveBasis</code> to a real space grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plotting.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.plot_band_diagram-Tuple{Function,Any}" href="#Peacock.plot_band_diagram-Tuple{Function,Any}"><code>Peacock.plot_band_diagram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_band_diagram(my_solve::Function, ks, &lt;keyword arguments&gt;)</code></pre><p>Plot the bands generated by <code>my_solve(k)</code> along <code>ks</code>.</p><p>Keyword arguments</p><ul><li><code>dk=nothing</code>: maximum distance between points</li><li><code>labels=[]</code>: overwrite the labels for each <code>k</code> in <code>ks</code></li><li><code>bands=(:)</code>: indices of the bands to plot</li><li><code>frequency_scale=1</code>: rescales the frequencies before plotting</li><li><code>color=&quot;k&quot;</code>: color of the bands</li><li><code>markersize=nothing</code>: overwrite the size of each point</li><li><code>show_vlines=true</code>: plot vertical lines at each <code>k</code> in <code>ks</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/band_diagrams.jl#L41-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.plot_band_diagram-Tuple{Solver,Any,Peacock.Polarisation}" href="#Peacock.plot_band_diagram-Tuple{Solver,Any,Peacock.Polarisation}"><code>Peacock.plot_band_diagram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_band_diagram(solver::Solver, ks, polarisation::Polarisation, &lt;keyword arguments&gt;)</code></pre><p>Plot the bands generated by <code>solve(solver, k, polarisation)</code> along <code>ks</code>.</p><p>Takes the same keyword arguments as <a href="#Peacock.plot_band_diagram-Tuple{Function,Any}"><code>plot_band_diagram(my_solve::Function, ks)</code></a>, but here <code>ks</code> can also include <a href="#Peacock.BrillouinZoneCoordinate"><code>BrillouinZoneCoordinate</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/band_diagrams.jl#L84-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.plot_wilson_loop_winding-Tuple{Solver,Any,Any,AbstractArray{#s46,1} where #s46&lt;:Int64}" href="#Peacock.plot_wilson_loop_winding-Tuple{Solver,Any,Any,AbstractArray{#s46,1} where #s46&lt;:Int64}"><code>Peacock.plot_wilson_loop_winding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_wilson_loop_winding(solver::Solver, ks, polarisation, bands::AbstractVector{&lt;:Int}, &lt;keyword arguments&gt;)</code></pre><p>Perform a series of Wilson loops along <code>ks</code>, and plot the spectra on a band diagram.</p><p>Keyword arguments</p><ul><li><code>dk_outer=nothing</code>: maximum distance between each loop (resolution of the scan)</li><li><code>dk_inner</code>: maximum distance between points along a loop (resolution of the loop)</li><li><code>labels=[]</code>: overwrite the labels for each <code>k</code> in <code>ks</code></li><li><code>delta_brillouin_zone=BrillouinZoneCoordinate(0,1)</code>: each Wilson loop starts at and finishes in at the same <code>k</code> in different Brillouin zones</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/wilson_loops.jl#L141-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.solve" href="#Peacock.solve"><code>Peacock.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve(solver::Solver, x::BrillouinZoneCoordinate, polarisation::Polarisation; bands=:)</code></pre><p>Calculate the eigenmodes of a photonic crystal at position <code>k=x.p*b1 + x.q*b2</code> in reciprocal space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/solver.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.solve-Tuple{Solver,AbstractArray{#s13,1} where #s13&lt;:Real,Peacock.Polarisation}" href="#Peacock.solve-Tuple{Solver,AbstractArray{#s13,1} where #s13&lt;:Real,Peacock.Polarisation}"><code>Peacock.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(solver::Solver, k::AbstractVector{&lt;:Real}, polarisation::Polarisation; bands=:)</code></pre><p>Calculate the eigenmodes of a photonic crystal at position <code>k</code> in reciprocal space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/solver.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PyPlot.plot-Tuple{Geometry}" href="#PyPlot.plot-Tuple{Geometry}"><code>PyPlot.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot(geometry::Geometry)</code></pre><p>Plot the permittivity and permeability of the <code>geometry</code> in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plotting.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PyPlot.plot-Tuple{Mode}" href="#PyPlot.plot-Tuple{Mode}"><code>PyPlot.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot(mode::Mode, [bloch_phase=true])</code></pre><p>Plot the mode in real space.</p><p>To plot only the cell-periodic part of the Bloch wave, set <code>bloch_phase=false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plotting.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PyPlot.plot-Tuple{Solver}" href="#PyPlot.plot-Tuple{Solver}"><code>PyPlot.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot(solver::Solver)</code></pre><p>Plot the representation of the <code>solver</code>&#39;s geometry in real space.</p><p>The <code>solver</code> approximates the geometry using a truncated basis of plane waves, so <code>plot(solver)</code> lets us judge how accurately the geometry is represented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plotting.jl#L109-L116">source</a></section></article><h2 id="Private-interface"><a class="docs-heading-anchor" href="#Private-interface">Private interface</a><a id="Private-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Private-interface" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">The `Peacock.jl` namespace</header><div class="admonition-body"><p>The following objects are used internally, and aren&#39;t exported to the global namespace. However, they may be useful for more advanced users, in which case you should use <code>Peacock.[name]</code> to access these.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Peacock.DiagonalMatrix" href="#Peacock.DiagonalMatrix"><code>Peacock.DiagonalMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiagonalMatrix(diag::AbstractVector{ComplexF64})</code></pre><p>A sparse diagonal matrix that can be used in left division (D \ X)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/utils.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.PlaneWaveBasis" href="#Peacock.PlaneWaveBasis"><code>Peacock.PlaneWaveBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PlaneWaveBasis(b1::Vector{Float64}, b2::Vector{Float64},
        ps::Vector{Int}, qs::Vector{Int})</code></pre><p>A 2D basis of plane waves, <code>ks = ps*b1 + qs*b2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plane_wave_basis.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.PlaneWaveBasis-Tuple{Geometry,Int64,Int64}" href="#Peacock.PlaneWaveBasis-Tuple{Geometry,Int64,Int64}"><code>Peacock.PlaneWaveBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Solver(geometry::Geometry, cutoff_b1::Int, cutoff_b2::Int)</code></pre><p>Approximate the geometry using a basis of plane waves truncated in a rhombus.</p><p>The rhombus has lengths <code>cutoff_b1</code> and <code>cutoff_b2</code> in the <code>b1</code> and <code>b2</code> directions, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plane_wave_basis.jl#L49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.PlaneWaveBasis-Tuple{Geometry,Int64}" href="#Peacock.PlaneWaveBasis-Tuple{Geometry,Int64}"><code>Peacock.PlaneWaveBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PlaneWaveBasis(geometry::Geometry, cutoff::Int)</code></pre><p>Approximate a basis of plane waves truncated in a circle.</p><p>The circle has a diameter of <code>cutoff</code> Brillouin zones. Increasing the <code>cutoff</code> will increase the number of plane waves leading to a more accurate solution. It is assumed that <code>norm(b1) == norm(b2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plane_wave_basis.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.Polarisation" href="#Peacock.Polarisation"><code>Peacock.Polarisation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Transverse electric (TE) or transverse magnetic (TM) polarisation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.as_to_bs-Tuple{Any,Any}" href="#Peacock.as_to_bs-Tuple{Any,Any}"><code>Peacock.as_to_bs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">as_to_bs(a1, a2)</code></pre><p>Calculate reciprocal lattice vectors, <code>b1</code> and <code>b2</code>, from the real space lattice vectors, <code>a1</code> and <code>a2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/utils.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.bs_to_as-Tuple{Any,Any}" href="#Peacock.bs_to_as-Tuple{Any,Any}"><code>Peacock.bs_to_as</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bs_to_as(b1, b2)</code></pre><p>Calculate real space lattice vectors, <code>a1</code> and <code>a2</code>, from reciprocal lattice vectors, <code>b1</code> and <code>b2</code>.</p><p>This is actually the same as <code>as_to_bs</code>, but I think having both functions makes the intention of the code more obvious.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/utils.jl#L14-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.convmat-Tuple{AbstractArray{T,2} where T,Peacock.PlaneWaveBasis}" href="#Peacock.convmat-Tuple{AbstractArray{T,2} where T,Peacock.PlaneWaveBasis}"><code>Peacock.convmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convmat(mat::AbstractMatrix, basis::PlaneWaveBasis)</code></pre><p>Generate convolution matrices, see Raymond Rumpf&#39;s CEM Lecture #18, &quot;Maxwell&#39;s Equations in Fourier Space&quot;, for further reading.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/solver.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.get_k-Tuple{BrillouinZoneCoordinate,Peacock.PlaneWaveBasis}" href="#Peacock.get_k-Tuple{BrillouinZoneCoordinate,Peacock.PlaneWaveBasis}"><code>Peacock.get_k</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_k(coord::BrillouinZoneCoordinate, basis::PlaneWaveBasis)</code></pre><p>Return the k-space coordinate of the <code>BrillouinZoneCoordinate</code> in a particular <code>PlaneWaveBasis</code>, ie <code>k = p*b1 + q*b2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plane_wave_basis.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.normalise-Tuple{Any}" href="#Peacock.normalise-Tuple{Any}"><code>Peacock.normalise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalise(data; weighting=I)</code></pre><p>Normalisation of vectors with a weighted inner product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/modes.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.orthonormalise-Tuple{Any}" href="#Peacock.orthonormalise-Tuple{Any}"><code>Peacock.orthonormalise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orthonormalise(data; weighting=I)</code></pre><p>Gram-Schmidt orthonormalisation of vectors with a weighted inner product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/modes.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.overlaps-Tuple{HilbertSpace,HilbertSpace}" href="#Peacock.overlaps-Tuple{HilbertSpace,HilbertSpace}"><code>Peacock.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">overlaps(a::HilbertSpace, b::HilbertSpace)</code></pre><p>Calculate the overlaps between the basis vectors of each Hilbert space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/wilson_loops.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.plot_field-Tuple{AbstractArray{#s47,1} where #s47&lt;:Complex,Peacock.PlaneWaveBasis}" href="#Peacock.plot_field-Tuple{AbstractArray{#s47,1} where #s47&lt;:Complex,Peacock.PlaneWaveBasis}"><code>Peacock.plot_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_field(data::AbstractVector{&lt;:Complex}, basis::PlaneWaveBasis;
                    k0=[0,0], cmap=&quot;coolwarm&quot;, vmin=nothing, vmax=nothing, label=nothing)</code></pre><p>Converts the plane-wave amplitudes to real space using <a href="#Peacock.get_field-Tuple{AbstractArray{#s38,1} where #s38&lt;:Complex,Peacock.PlaneWaveBasis}"><code>get_field</code></a> and then plots the field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plotting.jl#L82-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.plot_field-Tuple{Array{#s40,2} where #s40&lt;:Complex,Array{#s39,1} where #s39&lt;:Real,Array{#s38,1} where #s38&lt;:Real}" href="#Peacock.plot_field-Tuple{Array{#s40,2} where #s40&lt;:Complex,Array{#s39,1} where #s39&lt;:Real,Array{#s38,1} where #s38&lt;:Real}"><code>Peacock.plot_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_field(field::Array{&lt;:Real,2}, a1::Array{&lt;:Real,1}, a2::Array{&lt;:Real,1}; cmap=&quot;coolwarm&quot;, vmin=nothing, vmax=nothing)</code></pre><p>Plot the complex-valued <code>field</code> on a unit cell with lattice vectors <code>a1</code> and <code>a2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plotting.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.plot_field-Tuple{Array{#s40,2} where #s40&lt;:Real,Array{#s41,1} where #s41&lt;:Real,Array{#s42,1} where #s42&lt;:Real}" href="#Peacock.plot_field-Tuple{Array{#s40,2} where #s40&lt;:Real,Array{#s41,1} where #s41&lt;:Real,Array{#s42,1} where #s42&lt;:Real}"><code>Peacock.plot_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_field(field::Array{&lt;:Real,2}, a1::Array{&lt;:Real,1}, a2::Array{&lt;:Real,1}; cmap=&quot;coolwarm&quot;, vmin=nothing, vmax=nothing)</code></pre><p>Plot the real-valued <code>field</code> on a unit cell with lattice vectors <code>a1</code> and <code>a2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/plotting.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.sample_path-Tuple{Any}" href="#Peacock.sample_path-Tuple{Any}"><code>Peacock.sample_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_path(ks; [labels=[]], [dk=nothing])</code></pre><p>Return a path through <code>ks</code> where <code>dk</code> is the maximum distance between points.</p><p>If <code>dk==nothing</code> then there will be approximately 10 points between ks[1] and ks[2].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/band_diagrams.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.shift_k0-Tuple{HilbertSpace,Int64,Int64}" href="#Peacock.shift_k0-Tuple{HilbertSpace,Int64,Int64}"><code>Peacock.shift_k0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shift_k0(space::HilbertSpace, dp::Int, dq::Int)</code></pre><p>Shift the basis of the Hilbert space by <code>dp*b1 + dq*b2</code>, where <code>b1</code> and <code>b2</code> are reciprocal lattice vectors.</p><p>This is required when we need the overlaps of modes that are at the same k-point but in different Brillouin zones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/modes.jl#L60-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.unitary_approx-Tuple{AbstractArray}" href="#Peacock.unitary_approx-Tuple{AbstractArray}"><code>Peacock.unitary_approx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unitary_approx(M::AbstractArray)</code></pre><p>Calculate the best unitary approxmation of <code>M</code> using singular value decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/wilson_loops.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.unitary_overlaps-Tuple{HilbertSpace,HilbertSpace}" href="#Peacock.unitary_overlaps-Tuple{HilbertSpace,HilbertSpace}"><code>Peacock.unitary_overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unitary_overlaps(a::HilbertSpace, b::HilbertSpace)</code></pre><p>Shortcut for unitary_approx(overlaps(a, b))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/wilson_loops.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.wilson_eigen-Tuple{AbstractArray{HilbertSpace,1}}" href="#Peacock.wilson_eigen-Tuple{AbstractArray{HilbertSpace,1}}"><code>Peacock.wilson_eigen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wilson_eigvals(spaces::AbstractArray{HilbertSpace,1}; closed=true)</code></pre><p>Return the eigenvalues and eigenvectors of <a href="#Peacock.wilson_matrix-Tuple{Array{HilbertSpace,1}}"><code>wilson_matrix</code></a>, sorted by the phase angle of the eigenvalues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/wilson_loops.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.wilson_eigvals-Tuple{AbstractArray{HilbertSpace,1}}" href="#Peacock.wilson_eigvals-Tuple{AbstractArray{HilbertSpace,1}}"><code>Peacock.wilson_eigvals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wilson_eigvals(spaces::AbstractArray{HilbertSpace,1}; closed=true)</code></pre><p>Return the eigenvalues of <a href="#Peacock.wilson_matrix-Tuple{Array{HilbertSpace,1}}"><code>wilson_matrix</code></a>, sorted by phase angle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/wilson_loops.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.wilson_gauge-Tuple{AbstractArray{HilbertSpace,1}}" href="#Peacock.wilson_gauge-Tuple{AbstractArray{HilbertSpace,1}}"><code>Peacock.wilson_gauge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wilson_gauge(spaces::AbstractArray{HilbertSpace,1}; closed=true)</code></pre><p>Return the eigenvalues, eigenvectors, and gauge of the Wilson loop through the Hilbert space, sorted by the phase angle of the eigenvalues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/wilson_loops.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Peacock.wilson_matrix-Tuple{Array{HilbertSpace,1}}" href="#Peacock.wilson_matrix-Tuple{Array{HilbertSpace,1}}"><code>Peacock.wilson_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wilson_matrix(spaces::Array{HilbertSpace,1}; closed::Bool=true)</code></pre><p>Calculate the Wilson loop matrix through the Hilbert spaces.</p><p>The <code>closed</code> keyword will assert that <code>spaces[1] == spaces[end]</code>. Otherwise, it will be assumed that the Wilson loop begins and finishes at the same <code>k0</code>, but in different Brillouin zones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sp94/Peacock.jl/blob/7b8da84e772de5be1c36c65c1e145d5fcc93bae2/src/wilson_loops.jl#L40-L48">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../how-tos/wilson_loops/">« How to study band topology with Wilson loops</a><a class="docs-footer-nextpage" href="../contributing/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 24 July 2020 13:39">Friday 24 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
