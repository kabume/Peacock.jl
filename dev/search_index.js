var documenterSearchIndex = {"docs":
[{"location":"reference/#Technical-reference-1","page":"Technical reference","title":"Technical reference","text":"","category":"section"},{"location":"reference/#","page":"Technical reference","title":"Technical reference","text":"Modules = [Peacock]","category":"page"},{"location":"reference/#Peacock.BrillouinZoneCoordinate","page":"Technical reference","title":"Peacock.BrillouinZoneCoordinate","text":"BrillouinZoneCoordinate(p::Float64, q::Float64, label::String=\"\")\n\nA labelled coordinate in the Brillouin zone.\n\nThe arguments p and q are the coefficients of reciprocal lattice vectors b1 and b2. The k-space coordinate, k = p * b1 + q * b2, is generated by get_k(coord::BrillouinZoneCoordinate, basis::PlaneWaveBasis). For example, BrillouinZoneCoordinate(0.5,0) is on the edge of the first Brillouin zone.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Peacock.Geometry","page":"Technical reference","title":"Peacock.Geometry","text":"2D geometry defined in real space.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Peacock.Geometry-Tuple{Function,Function,Array{#s18,1} where #s18<:Real,Array{#s19,1} where #s19<:Real,Real,Real}","page":"Technical reference","title":"Peacock.Geometry","text":"Geometry(epf::Function, muf::Function, a1::Array{<:Real,1}, a2::Array{<:Real,1}, d1::Real, d2::Real)\n\nGenerate geometry with permittivity epf(x,y) and permeability muf(x,y).\n\nThe real space lattice vectors, a1 and a2, define the unit cell. The grid resolution along each lattice vector is d1 and d2, respectively.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.Geometry-Tuple{Function,Function,Real,Real,Real,Real}","page":"Technical reference","title":"Peacock.Geometry","text":"Geometry(epf::Function, muf::Function, a1::Array{<:Real,1}, a2::Array{<:Real,1}, d1::Real, d2::Real)\n\nGenerate geometry with permittivity epf(x,y) and permeability muf(x,y).\n\nThe real space lattice vectors are assumed to have unit length and are at angles a1_deg and a2_deg counter-clockwise from the x-axis. The grid resolution along each lattice vector is d1 and d2, respectively.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.HilbertSpace-Tuple{Array{Mode,1}}","page":"Technical reference","title":"Peacock.HilbertSpace","text":"HilbertSpace(modes::Array{Mode,1})\n\nReturns the Hilbert space spanned by the modes.\n\nThe data of the Hilbert space is guaranteed to be orthonormal under the weighting of the modes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.Mode","page":"Technical reference","title":"Peacock.Mode","text":"Mode(k0, frequency, data, weighting, basis, label)\n\nEigenmode of a photonic crystal expressed on a plane-wave basis with a weighted inner product.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Peacock.Solver-Tuple{Geometry,Int64}","page":"Technical reference","title":"Peacock.Solver","text":"Solver(geometry::Geometry, cutoff::Int)\n\nApproximate the geometry using a truncated basis of plane waves.\n\nIncreasing the cutoff will increase the number of plane waves leading to a more accurate solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.get_field-Tuple{AbstractArray{#s36,1} where #s36<:Complex,Peacock.PlaneWaveBasis}","page":"Technical reference","title":"Peacock.get_field","text":"get_field(data::AbstractVector{<:Complex}, basis::PlaneWaveBasis;\n                    k0=[0,0], t1s=-0.5:0.01:0.5, t2s=-0.5:0.01:0.5)\n\nConvert the data from a PlaneWaveBasis to a real space grid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.plot_band_diagram-Tuple{Function,Any}","page":"Technical reference","title":"Peacock.plot_band_diagram","text":"plot_band_diagram(my_solve::Function, ks, <keyword arguments>)\n\nPlot the bands generated by my_solve(k) along ks.\n\nKeyword arguments\n\ndk=nothing: maximum distance between points\nlabels=[]: overwrite the labels for each k in ks\nbands=(:): indices of the bands to plot\nfrequency_scale=1: rescales the frequencies before plotting\ncolor=\"k\": color of the bands\nmarkersize=nothing: overwrite the size of each point\nshow_vlines=true: plot vertical lines at each k in ks\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.plot_band_diagram-Tuple{Solver,Any,Peacock.Polarisation}","page":"Technical reference","title":"Peacock.plot_band_diagram","text":"plot_band_diagram(solver::Solver, ks, polarisation::Polarisation, <keyword arguments>)\n\nPlot the bands generated by solve(solver, k, polarisation) along ks.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.plot_wilson_loop_winding-Tuple{Solver,Any,Any,AbstractArray{#s44,1} where #s44<:Int64}","page":"Technical reference","title":"Peacock.plot_wilson_loop_winding","text":"plot_wilson_loop_winding(solver::Solver, ks, polarisation, bands::AbstractVector{<:Int}, <keyword arguments>)\n\nPerform a series of Wilson loops along ks, and plot the spectra on a band diagram.\n\nKeyword arguments\n\ndk=nothing: maximum distance between points\nlabels=[]: overwrite the labels for each k in ks\ndelta_brillouin_zone=BrillouinZoneCoordinate(0,1): each Wilson loop starts at and finishes in at the same k in different Brillouin zones\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.solve-Tuple{Solver,AbstractArray{#s13,1} where #s13<:Real,Peacock.Polarisation}","page":"Technical reference","title":"Peacock.solve","text":"solve(solver::Solver, k::AbstractVector{<:Real}, polarisation::Polarisation; bands=:)\n\nCalculate the eigenmodes of a photonic crystal at position k in reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PyPlot.plot-Tuple{Geometry}","page":"Technical reference","title":"PyPlot.plot","text":"plot(geometry::Geometry)\n\nPlot the permittivity and permeability of the geometry in real space.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PyPlot.plot-Tuple{Mode}","page":"Technical reference","title":"PyPlot.plot","text":"plot(mode::Mode, [bloch_phase=true])\n\nPlot the mode in real space.\n\nTo plot only the cell-periodic part of the Bloch wave, set bloch_phase=false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PyPlot.plot-Tuple{Solver}","page":"Technical reference","title":"PyPlot.plot","text":"plot(solver::Solver)\n\nPlot the representation of the solver's geometry in real space.\n\nThe solver approximates the geometry using a truncated basis of plane waves, so plot(solver) lets us judge how accurately the geometry is represented.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.DiagonalMatrix","page":"Technical reference","title":"Peacock.DiagonalMatrix","text":"A sparse diagonal matrix that can be used in left division (D \\ X)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Peacock.PlaneWaveBasis-Tuple{Geometry,Int64}","page":"Technical reference","title":"Peacock.PlaneWaveBasis","text":"PlaneWaveBasis(geometry::Geometry, cutoff::Int)\n\nGenerate a plane-wave basis for solving Maxwell's equations in the unit cell of the geometry.\n\nIncreasing the cutoff will increase the number of plane waves, leading to a more accurate solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.Polarisation","page":"Technical reference","title":"Peacock.Polarisation","text":"Transverse electric (TE) or transverse magnetic (TM) polarisation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Peacock.as_to_bs-Tuple{Any,Any}","page":"Technical reference","title":"Peacock.as_to_bs","text":"as_to_bs(a1, a2)\n\nCalculate reciprocal lattice vectors, b1 and b2, from the real space lattice vectors, a1 and a2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.bs_to_as-Tuple{Any,Any}","page":"Technical reference","title":"Peacock.bs_to_as","text":"bs_to_as(b1, b2)\n\nCalculate real space lattice vectors, a1 and a2, from reciprocal lattice vectors, b1 and b2.\n\nThis is actually the same as as_to_bs, but I think having both functions makes the intention of the code more obvious.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.convmat-Tuple{AbstractArray{T,2} where T,Peacock.PlaneWaveBasis}","page":"Technical reference","title":"Peacock.convmat","text":"convmat(mat::AbstractMatrix, basis::PlaneWaveBasis)\n\nGenerate convolution matrices, see Raymond Rumpf's CEM Lecture #18, \"Maxwell's Equations in Fourier Space\", for further reading.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.get_k-Tuple{BrillouinZoneCoordinate,Peacock.PlaneWaveBasis}","page":"Technical reference","title":"Peacock.get_k","text":"get_k(coord::BrillouinZoneCoordinate, basis::PlaneWaveBasis)\n\nReturn the k-space coordinate of the BrillouinZoneCoordinate in a particular PlaneWaveBasis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.normalise-Tuple{Any}","page":"Technical reference","title":"Peacock.normalise","text":"normalise(data; weighting=I)\n\nNormalisation of vectors with a weighted inner product.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.orthonormalise-Tuple{Any}","page":"Technical reference","title":"Peacock.orthonormalise","text":"orthonormalise(data; weighting=I)\n\nGram-Schmidt orthonormalisation of vectors with a weighted inner product.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.overlaps-Tuple{HilbertSpace,HilbertSpace}","page":"Technical reference","title":"Peacock.overlaps","text":"overlaps(a::HilbertSpace, b::HilbertSpace)\n\nCalculate the overlaps between the basis vectors of each Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.plot_field-Tuple{AbstractArray{#s45,1} where #s45<:Complex,Peacock.PlaneWaveBasis}","page":"Technical reference","title":"Peacock.plot_field","text":"To do\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.plot_field-Tuple{Array{#s38,2} where #s38<:Complex,Array{#s37,1} where #s37<:Real,Array{#s36,1} where #s36<:Real}","page":"Technical reference","title":"Peacock.plot_field","text":"plot_field(field::Array{<:Real,2}, a1::Array{<:Real,1}, a2::Array{<:Real,1}; cmap=\"coolwarm\", vmin=nothing, vmax=nothing)\n\nPlot the complex-valued field on a unit cell with lattice vectors a1 and a2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.plot_field-Tuple{Array{#s39,2} where #s39<:Real,Array{#s40,1} where #s40<:Real,Array{#s41,1} where #s41<:Real}","page":"Technical reference","title":"Peacock.plot_field","text":"plot_field(field::Array{<:Real,2}, a1::Array{<:Real,1}, a2::Array{<:Real,1}; cmap=\"coolwarm\", vmin=nothing, vmax=nothing)\n\nPlot the real-valued field on a unit cell with lattice vectors a1 and a2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.sample_path-Tuple{Any}","page":"Technical reference","title":"Peacock.sample_path","text":"sample_path(ks; [labels=[]], [dk=nothing])\n\nReturn a path through ks where dk is the maximum distance between points.\n\nIf dk==nothing then there will be approximately 10 points between ks[1] and ks[2].\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.shift_k0-Tuple{HilbertSpace,Int64,Int64}","page":"Technical reference","title":"Peacock.shift_k0","text":"shift_k0(space::HilbertSpace, dp::Int, dq::Int)\n\nShift the basis of the Hilbert space by dp*b1 + dq*b2, where b1 and b2 are reciprocal lattice vectors.\n\nThis is required when we need the overlaps of modes that are at the same k-point but in different Brillouin zones.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.unitary_approx-Tuple{AbstractArray}","page":"Technical reference","title":"Peacock.unitary_approx","text":"unitary_approx(M::AbstractArray)\n\nCalculate the best unitary approxmation of M using singular value decomposition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.unitary_overlaps-Tuple{HilbertSpace,HilbertSpace}","page":"Technical reference","title":"Peacock.unitary_overlaps","text":"unitary_overlaps(a::HilbertSpace, b::HilbertSpace)\n\nShortcut for unitary_approx(overlaps(a, b))\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.wilson_eigen-Tuple{AbstractArray{HilbertSpace,1}}","page":"Technical reference","title":"Peacock.wilson_eigen","text":"wilson_eigvals(spaces::AbstractArray{HilbertSpace,1}; closed=true)\n\nReturn the eigenvalues and eigenvectors of the Wilson matrix through a Hilbert space, sorted by the phase angle of the eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.wilson_eigvals-Tuple{AbstractArray{HilbertSpace,1}}","page":"Technical reference","title":"Peacock.wilson_eigvals","text":"wilson_eigvals(spaces::AbstractArray{HilbertSpace,1}; closed=true)\n\nReturn the eigenvalues of the Wilson matrix through a Hilbert space, sorted by phase angle.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.wilson_gauge-Tuple{AbstractArray{HilbertSpace,1}}","page":"Technical reference","title":"Peacock.wilson_gauge","text":"wilson_gauge(spaces::AbstractArray{HilbertSpace,1}; closed=true)\n\nReturn the eigenvalues, eigenvectors, and gauge of the Wilson loop through the Hilbert space, sorted by the phase angle of the eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Peacock.wilson_matrix-Tuple{Array{HilbertSpace,1}}","page":"Technical reference","title":"Peacock.wilson_matrix","text":"wilson_matrix(spaces::Array{HilbertSpace,1}; closed::Bool=true)\n\nCalculate the Wilson loop matrix through the Hilbert spaces.\n\nThe closed keyword \n\n\n\n\n\n","category":"method"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Peacock.jl - or the Plane-wave Expansion Approach to Characterising Optical Crystals in k-space - is a Julia package for studying photonic crystals using the Plane Wave Expansion Method.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Solve for...\nTransverse electric (TE) and transverse magnetic (TM) modes of 2D photonic crystals\nNon-orthogonal unit cells\nInhomogeneous permittivity and/or permeability\nChern numbers of topological photonic crystals using built-in Wilson loop methods","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Focused on ease of use\nInstall with one line in Julia's package manager\nSimple visualisation of geometry, fields, and fully labelled band diagrams","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Photonic crystals are materials whose optical properties arise from the structuring of the material when the size of the structures are comparable to the wavelengths of light. Peacock.jl is named for the irridescent colours of peacock feathers which arise not from pigmentation but from their photonic crystal structure, as shown below.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: Different zooms of a Peacock) Peacock by allanlau2000 from pixabay. Feather by suju from pixabay. Electron microscope image of photonic crystal structure from Zi, Jian, et al. \"Coloration strategies in peacock feathers.\",  Proceedings of the National Academy of Sciences 100.22 (2003): 12576-12578. Copyright (2003) National Academy of Sciences.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"As well as occuring naturally as in animals such as peacocks, advances in nanofabrication mean that 'designer' photonic crystals can now be manufactured for unprecedented control over the flow of light, with applications ranging from optical fibers to photonic circuitry. Photonic crystals are also a promising platform for more exotic materials like topological insulators.","category":"page"},{"location":"#Index-1","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n        \"tutorials/getting_started.md\",\n        \"reference/index.md\"]","category":"page"}]
}
